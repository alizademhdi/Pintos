تمرین گروهی ۳ - مستند طراحی
======================

گروه
-----

>>‫نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

مقدمات
----------

>>‫ ‫‫اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  ‫بنویسید.

>>‫ لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع‫ ‫درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

بافر کش
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را‫ بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```C
#define CACHE_SIZE 64

struct cache_block {
    block_sector_t sector_index;
    char data[BLOCK_SECTOR_SIZE];
    bool valid;
    bool dirty;
    struct list_elem elem; 
    struct lock block_lock;

}

struct cache_block cache_blocks[CACHE_SIZE];
struct list cache_list;
struct lock cache_lock;

```
الگوریتم‌ها
------------

>>‫ توضیح دهید که الگوریتم مورد استفاده‌ی شما به چه صورت یک بلاک را برای جایگزین ‫ شدن انتخاب می‌کند؟

به علت برتری الگوریتم LRU و نیز سادگی نسبی پیاده‌سازی، آن را انتخاب می‌کنیم.
ابتدا در تابع `cache_init` عناصر آرایه `cache_blocks` را آماده کرده و در لیست `cache_list` قرار می‌دهیم.

حال هرزمان که خواستیم از یک بلاک استفاده کنیم، آن را به ابتدای لیست می‌آوریم. هر زمان که بلاک جدیدی می‌خواستیم نیز از انتهای صف آن را انتخاب می‌کنیم.
اینگونه مطمئن می‌شویم که همواره بلاک انتخاب شده، LRU



>>‫ روش پیاده‌سازی `read-ahead` را توضیح دهید.

هنگام خواندن یک سکتور از حافظه، تعداد سکتورهایی که دقیقا پیش از این سکتور در حافظه قرار دارند را می‌شماریم. حال با تناسب با این عدد، سکتورهای بیشتری از حافظه در همین read می‌خوانیم تا اگر برنامه جلوتر به این سکتورها نیاز داشت، مجبور به خواندن دوباره آنها از حافظه اصلی نشویم.

برای این کار یک ترد جدید می‌سازیم تا در پسزمینه، سکتورهای خواسته شده را وارد کش کند. اگر این کار در ترد جدایی انجام نشود، بجای تسریع ممکن است موجب کند شدن برنامه‌ی کاربر شود. :)

همگام سازی
-------------

>>‫ هنگامی که یک پردازه به طور مستمر در حال خواندن یا نوشتن داده در یک بلاک بافرکش‫ می‌باشد به چه صورت از دخالت سایر پردازه‌ها جلوگیری میشود؟

هر بلاک cache
یک lock
مخصوص‌به‌خود دارد و به این شکل، اطمینان حاصل می‌کنیم که دوتا process
به‌طور هم‌زمان در یک cache
درحال خواندن یا نوشتن نیستند.

به این صورت و با ایجاد mutual exclusion
امکان این‌که processها
در کار یک‌دیگر دخالت کنند وجود ندارد.

همچنین داشتن یک lock کلی برای لیست بلوک‌های بافر کش، باعث می‌شود دسترسی به عناصر به درستی انجام شود و اشتباهی در کنترل لیست
رخ ندهد. همچنین هیچ read یا write مستقیمی نداریم و همه read و write های فعلی با کش جایگزین خواهند شد.


>>‫ در حین خارج شدن یک بلوک از حافظه‌ی نهان، چگونه از پروسه‌های دیگر جلوگیری می‌شود تا‫ به این بلاک دسترسی پیدا نکنند؟

خارج‌شدن بلاک از حافظه cache نیز نیاز به acquireکردن lock
آن بلاک دارد و به همین دلیل، با توجه به mutual exclusion
ایجادشده به‌دلیل lockها،
درحین خارج‌شدن یک بلاک از cache
هیچ processی
امکان دسترسی به آن بلاک را نخواهد داشت.

منطق طراحی
-----------------

>>‫ یک سناریو را توضیح دهید که از بافر کش، `read-ahead` و یا از `write-behind` استفاده کند.

شاید بتوان `write-behind` را به یک autosave تشبیه کرد. بدون این عملیات ممکن است یک داده مدت طولانی در کش باقی بماند و در صورت استفاده از کش `write-back` ممکن است پیش از انتقال به حافظه اصلی به علت مشکلی در کرنل یا قطع شدن برق، مقدار جدید آن وارد حافظه اصلی نشود.

برای اینکه تعداد درخواست‌ها به یک سرور کمینه شود، ممکن است بخش‌های بیشتری در یک ریکوئست خواسته شود و در کش قرار گیرد تا در مرتبه‌های بعدی، نیازی به فرستادن درخواست نباشد. به این مدل خواندن از حافظه`read-ahead` می‌گویند.

فایل‌های قابل گسترش
=====================

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

>>‫ بیشترین سایز فایل پشتیبانی شده توسط ساختار inode شما چقدر است؟

همگام سازی
----------

>>‫ توضیح دهید که اگر دو پردازه بخواهند یک فایل را به طور همزمان گسترش دهند، کد شما چگونه از‫ حالت مسابقه جلوگیری می‌کند.

هر `struct inode`
در این طراحی، یک `struct lock`
دارد که acquireکردن
آن برای تمام عملیات‌هایی که با `inode`
سروکار دارند، الزامی است. این `struct lock` باعث ایجاد mutual exclusion
می‌شود و این اطمینان را ایجاد می‌کند که دو process
نمی‌توانند به‌طور هم‌زمان عملیاتی را روی یک `inode`
انجام دهند.

از طرف دیگر، گسترش فایل نیز در لایه‌هایی پایین‌تر با `inode`
سروکار دارد و به‌دلیل وجود mutual exclusion
می‌دانیم که race conditionی
رخ نخواهد داد.

>>‫ فرض کنید دو پردازه‌ی A و B فایل F را باز کرده‌اند و هر دو به end-of-file اشاره کرده‌اند.‫ اگر  همزمان A از F بخواند و B روی آن بنویسد، ممکن است که A تمام، بخشی یا هیچ چیز از‫ اطلاعات نوشته شده توسط B را بخواند. همچنین A نمی‌تواند چیزی جز اطلاعات نوشته شده توسط B را‫ بخواند. مثلا اگر B تماما ۱ بنویسد، A نیز باید تماما ۱ بخواند. توضیح دهید کد شما چگونه از‫ این حالت مسابقه جلوگیری می‌کند.

همان‌طور که بالاتر مطرح شد، تمام عملیات‌هایی که با `inode`ها
سروکار دارند باید از `struct lock`
استفاده کنند و mutual exclusion
وجود دارد.

در مثال مطرح شده، بسته به این‌که کدام process
زودتر `struct lock`
مربوط‌به این `inode`
را acquire
کند، دو حالت می‌تواند رخ دهد:

**۱. ابتدا A توانسته باشد
`struct lock`
را acquire
کند:**
در این صورت، A به انتهای فایل می‌رسد، `EOF`
دریافت می‌کند و کار با فایل را تمام می‌کند. سپس، A
که کارش با `inode`
تمام شده، `struct lock`
این `inode`
را release
می‌کند. سپس B
می‌تواند `struct lock`
را acquire
کند و دیتای موردنظر خود را در فایل بنویسد.

**۲. ابتدا B
توانسته باشد `struct lock`
را acquire کند:**
در این صورت، B
دیتای موردنظر خود را در فایل می‌نویسد. پس از این‌که کار B
تمام شد، `struct lock`
مربوط‌به این `inode`
را release
می‌کند و حالا A
می‌تواند این `struct lock`
را acquire
کند. سپس A
دیتایی که B
نوشته را می‌خواند و زمانی که به `EOF`
برسد، `struct lock`
را release
می‌کند.

>>‫ توضیح دهید همگام سازی شما چگونه "عدالت" را برقرار می‌کند. فایل سیستمی "عادل" است که‫ خواننده‌های اطلاعات به صورت ناسازگار نویسنده‌های اطلاعات را مسدود نکنند و برعکس. بدین ترتیب‫ اگر تعدادی بسیار زیاد پردازه‌هایی که از یک فایل می‌خوانند نمی‌توانند تا ابد مانع نوشده شدن‫ اطلاعات توسط یک پردازه‌ی دیگر شوند و برعکس.

در زمانی که چندین خواننده یا نویسنده، درحال wait
برای acquireکردن
`struct lock`
مربوط‌به یک `inode`
باشند و یک process
این `struct lock`
را release
کرده باشد،
کرنل یکی از آن‌ها را **به‌ترتیب زمان acquireکردن** انتخاب می‌کند
و `struct lock`
توسط process
انتخاب‌شده، acquire
خواهد شد.

این فرآیند، تضمین می‌کند که starvation
برای یک process
رخ نخواهد داد و رفتار کرنل fair
است.

منطق طراحی
----------

>>‫ آیا ساختار `inode` شما از طبقه‌بندی چند سطحه پشتیبانی می‌کند؟ اگر بله، دلیل خود را برای‫ انتخاب این ترکیب خاص از بلوک‌های مستقیم، غیر مستقیم و غیر مستقیم دوطرفه توضیح دهید.‌‫ اگر خیر، دلیل خود برای انتخاب ساختاری غیر از طبقه‌بندی چند سطحه و مزایا و معایب ساختار‫ مورد استفاده خود نسبت به طبقه‌بندی چند سطحه را توضیح دهید.

زیرمسیرها
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

الگوریتم‌ها
-----------

>>‫ کد خود را برای طی کردن یک مسیر گرفته‌شده از کاربر را توضیح دهید.‫ آیا عبور از مسیرهای absolute و relative تفاوتی دارد؟

همگام سازی
-------------

>>‫ چگونه از رخ دادن race-condition در مورد دایرکتوری ها پیشگیری می‌کنید؟‫ برای مثال اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد و ‫ تنها یکی از آنها باید موفق شود یا مثلاً دو ریسه موازی بخواهند فایلی‫ یک اسم در یک مسیر ایجاد کنند و مانند آن.‫ آیا پیاده سازی شما اجازه می‌دهد مسیری که CWD یک ریسه شده یا پردازه‌ای‫ از آن استفاده می‌کند حذف شود؟ اگر بله، عملیات فایل سیستم بعدی روی آن‫ دایرکتوری چه نتیجه‌ای می‌دهند؟ اگر نه، چطور جلوی آن را می‌گیرید؟

در طراحی ما، هر directory
نیز یک `struct inode`
است و همان‌طور که پیش‌تر مطرح شد، تمام `struct inode`ها
یک `struct lock`
دارند که وظیفه‌ي mutual exclusion
و پیش‌گیری از race condition
برعهده‌ی آن‌هاست.

اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد، به‌دلیل وجود mutual exclusion
این اطمینان را داریم که تنها یکی از آن‌ها موفق به acquireکردن
`struct lock`
مربوط‌به `struct inode`
موردنظر می‌شود.
به همین دلیل، اولین processی
که این درخواست را داده است موفق به انجام این عملیات می‌شود و process
دوم پس از releaseشدن
`struct lock`
توسط process
اول می‌تواند انجام عملیات را آغاز کند.
در آن لحظه نیز دیگر فایل وجود ندارد و process
دوم به‌سادگی، با خطا مواجه می‌شود.

در مثال ایجاد دو فایل با یک نام در یک مسیر نیز، process
اولی که موفق به acquireکردن
`struct lock`
مربوط‌به `struct inode`
متعلق‌به parent directory
شده است، فایل را می‌سازد. سپس `struct lock`
را release
می‌کند و در این‌جاست که process
دوم موفق به acquireکردن
`struct lock`
می‌شود. در این زمان نیز عملیات ایجاد فایل به‌دلیل وجود فایل ایجادشده توسط process
اول با خطا مواجه خواهد شد.

<!-- TODO: add answers to 3rd question. -->

منطق طراحی
-----------------

>>‫ توضیح دهید چرا تصمیم گرفتید CWD یک پردازه را به شکلی که طراحی کرده‌اید‫ پیاده‌سازی کنید؟

### سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد.

نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست.

ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>>‫ به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>>‫ آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>>‫ آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>>‫ آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>>‫ آیا حرف دیگری دارید؟
